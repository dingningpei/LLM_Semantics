#One column in the table may have multiple values, and the system should treat these multiple values as one column.
#When one column in the table may contains multiple values which represent different types of information, the system should only choose one type of information from the values to represent the column to form the SetSemanticType triples instead of separating the values into multiple columns. It make sure that the number of the SetSemanticType triples is the same as the number of the columns in the table.
# Messages Round 2: Certainly! To generate the semantic graph from the provided table, I follow a structured process that involves mapping the table columns to ontological concepts and establishing relationships between these concepts. Here's a step-by-step breakdown of how I do this:

# ### Step 1: Identify Semantic Types
# I identify the appropriate semantic types from the ontology for each column in the table. For example:

# - `id` and `Accession Number` can be mapped to `crm:E42_Identifier`.
# - `image` can be mapped to `crm:E38_Image`.
# - `Date`, `date_latest`, and `date_earliest` can be mapped to `crm:E52_Time-Span`.
# - `Geography` can be mapped to `crm:E53_Place`.
# - `Medium` and `Classification` can be mapped to `crm:E55_Type`.
# - `Credit Line` and `Provenance` can be mapped to `crm:E33_Linguistic_Object`.
# - `object_uri`, `type_assignment_uri`, and `production_uri` can be mapped to `foaf:Document`.
# - `Who` (Artist Name) can be mapped to `crm:E82_Actor_Appellation`.
# - `artist_uri` can be mapped to `crm:E39_Actor`.
# - `What` (Materials and Object Type) can be mapped to `skos:Concept`.
# - `Description` can be mapped to `crm:E33_Linguistic_Object`.

# ### Step 2: Establish Internal Links
# I establish internal links between the semantic types based on the relationships defined in the ontology. For example:

# - The `crm:E22_Man-Made_Object` (representing the object) is linked to `crm:E42_Identifier` (representing the ID and Accession Number) via the `crm:P1_is_identified_by` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E38_Image` (representing the image) via the `crm:P138i_has_representation` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E52_Time-Span` (representing the Date) via the `crm:P4_has_time-span` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E53_Place` (representing the Geography) via the `crm:P7_took_place_at` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E55_Type` (representing the Medium and Classification) via the `crm:P2_has_type` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E33_Linguistic_Object` (representing the Credit Line and Provenance) via the `crm:P67i_is_referred_to_by` property.
# - The `crm:E22_Man-Made_Object` is linked to `foaf:Document` (representing the object_uri, type_assignment_uri, and production_uri) via the `foaf:homepage` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E82_Actor_Appellation` (representing the Artist Name) via the `crm:P14_carried_out_by` property.
# - The `crm:E22_Man-Made_Object` is linked to `skos:Concept` (representing the Materials and Object Type) via the `dcterms:subject` property.
# - The `crm:E22_Man-Made_Object` is linked to `crm:E33_Linguistic_Object` (representing the Description) via the `crm:P67i_is_referred_to_by` property.

# ### Step 3: Construct the Semantic Graph
# Using the identified semantic types and established internal links, I construct the semantic graph. This graph consists of two main components:

# 1. **SetSemanticType**: A list of triples that link the columns in the table to the nodes in the ontology. Each triple has the form (subject, predicate, object), where the subject is the semantic type, the predicate is the property linking the subject to the object, and the object is the column in the table.

# 2. **SetInternalLink**: A list of triples that link the nodes in the semantic graph to each other. Each triple has the form (subject, predicate, object), where the subject and object are nodes in the ontology, and the predicate is the property defining the relationship between them.

# ### Example of SetSemanticType and SetInternalLink
# Here's an example of how some of the columns might be represented in the semantic graph:

# **SetSemanticType**:
# - ['crm:E42_Identifier1', 'rdf:value', 'id']
# - ['crm:E42_Identifier2', 'rdf:value', 'Accession Number']
# - ['crm:E38_Image1', 'karma:classLink', 'image']
# - ['crm:E52_Time-Span1', 'rdfs:label', 'Date']
# - ['crm:E53_Place1', 'rdfs:label', 'Geography']
# - ['crm:E55_Type1', 'rdfs:label', 'Medium']
# - ['crm:E55_Type2', 'rdfs:label', 'Classification']
# - ['crm:E33_Linguistic_Object1', 'rdf:value', 'Credit Line']
# - ['crm:E33_Linguistic_Object2', 'rdf:value', 'Provenance']
# - ['foaf:Document1', 'karma:classLink', 'object_uri']
# - ['foaf:Document2', 'karma:classLink', 'type_assignment_uri']
# - ['foaf:Document3', 'karma:classLink', 'production_uri']
# - ['crm:E82_Actor_Appellation1', 'rdf:value', 'Who']
# - ['skos:Concept1', 'skos:prefLabel', 'What']
# - ['crm:E33_Linguistic_Object3', 'rdf:value', 'Description']

# **SetInternalLink**:
# - ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier1']
# - ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier2']
# - ['crm:E22_Man-Made_Object1', 'crm:P138i_has_representation', 'crm:E38_Image1']
# - ['crm:E22_Man-Made_Object1', 'crm:P4_has_time-span', 'crm:E52_Time-Span1']
# - ['crm:E22_Man-Made_Object1', 'crm:P7_took_place_at', 'crm:E53_Place1']
# - ['crm:E22_Man-Made_Object1', 'crm:P2_has_type', 'crm:E55_Type1']
# - ['crm:E22_Man-Made_Object1', 'crm:P2_has_type', 'crm:E55_Type2']
# - ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object1']
# - ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object2']
# - ['crm:E22_Man-Made_Object1', 'foaf:homepage', 'foaf:Document1']
# - ['crm:E22_Man-Made_Object1', 'foaf:homepage', 'foaf:Document2']
# - ['crm:E22_Man-Made_Object1', 'foaf:homepage', 'foaf:Document3']
# - ['crm:E22_Man-Made_Object1', 'crm:P14_carried_out_by', 'crm:E82_Actor_Appellation1']
# - ['crm:E22_Man-Made_Object1', 'dcterms:subject', 'skos:Concept1']
# - ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object3']

# This process ensures that the data from the table is semantically enriched and linked according to the ontology, allowing for more sophisticated querying and analysis.
#The system will identify the appropriate semantic types from nodes in the ontology for each column in the table. 


Let's think step by step.

### Step 1: Establish Internal Links Between Semantic Types

1. **Identify Core Entities and Their Relationships:**
   - The core entity in this context is `crm:E22_Man-Made_Object1` (the object).
   - The object is produced (`crm:E12_Production1`), identified by (`crm:E42_Identifier1`), classified (`crm:E17_Type_Assignment1`), and has various descriptive attributes (`crm:E33_Linguistic_Object1`, `crm:E33_Linguistic_Object2`, `crm:E33_Linguistic_Object3`).

2. **Link Production to Object:**
   - `crm:E22_Man-Made_Object1` is produced by `crm:E12_Production1`.
   - `crm:E12_Production1` has a time span (`crm:E52_Time-Span1`).

3. **Link Object to Descriptive Attributes:**
   - `crm:E22_Man-Made_Object1` has a title (`crm:E35_Title1`), dimensions (`crm:E54_Dimension1`), medium (`crm:E57_Material1`), and geography (`crm:E53_Place1`).
   - `crm:E22_Man-Made_Object1` is classified by `crm:E17_Type_Assignment1`.

4. **Link Object to Identifiers:**
   - `crm:E22_Man-Made_Object1` is identified by `crm:E42_Identifier1` and `crm:E42_Identifier2`.

5. **Link Object to Artist:**
   - `crm:E12_Production1` is carried out by `crm:E39_Actor1` (artist).
   - `crm:E39_Actor1` is identified by `crm:E82_Actor_Appellation1`.

6. **Link Object to Keywords:**
   - `crm:E22_Man-Made_Object1` has keywords (`skos:Concept1`).

### Step 2: Review and Connect Isolated Nodes

1. **Check for Isolated Nodes:**
   - `crm:E38_Image1` (image) is isolated. It should be linked to the object.
   - `crm:E33_Linguistic_Object2` (Description) and `crm:E33_Linguistic_Object3` (Provenance) are isolated. They should be linked to the object.

2. **Update Step 1 to Include Missing Links:**
   - Add links for `crm:E38_Image1`, `crm:E33_Linguistic_Object2`, and `crm:E33_Linguistic_Object3` to `crm:E22_Man-Made_Object1`.

### Step 3: Finalize the Semantic Graph

1. **Final Internal Links:**
   - `crm:E22_Man-Made_Object1` is produced by `crm:E12_Production1`.
   - `crm:E12_Production1` has a time span (`crm:E52_Time-Span1`).
   - `crm:E22_Man-Made_Object1` is identified by `crm:E42_Identifier1` and `crm:E42_Identifier2`.
   - `crm:E22_Man-Made_Object1` has a title (`crm:E35_Title1`), dimensions (`crm:E54_Dimension1`), medium (`crm:E57_Material1`), and geography (`crm:E53_Place1`).
   - `crm:E22_Man-Made_Object1` is classified by `crm:E17_Type_Assignment1`.
   - `crm:E12_Production1` is carried out by `crm:E39_Actor1` (artist).
   - `crm:E39_Actor1` is identified by `crm:E82_Actor_Appellation1`.
   - `crm:E22_Man-Made_Object1` has keywords (`skos:Concept1`).
   - `crm:E22_Man-Made_Object1` has an image (`crm:E38_Image1`).
   - `crm:E22_Man-Made_Object1` has a description (`crm:E33_Linguistic_Object2`) and provenance (`crm:E33_Linguistic_Object3`).

### Step 4: Output the Final Internal Links

<Step2>
[
    ('crm:E22_Man-Made_Object1', 'crm:P108i_was_produced_by', 'crm:E12_Production1'),
    ('crm:E12_Production1', 'crm:P4_has_time-span', 'crm:E52_Time-Span1'),
    ('crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier1'),
    ('crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier2'),
    ('crm:E22_Man-Made_Object1', 'crm:P102_has_title', 'crm:E35_Title1'),
    ('crm:E22_Man-Made_Object1', 'crm:P43_has_dimension', 'crm:E54_Dimension1'),
    ('crm:E22_Man-Made_Object1', 'crm:P45_consists_of', 'crm:E57_Material1'),
    ('crm:E22_Man-Made_Object1', 'crm:P53_has_former_or_current_location', 'crm:E53_Place1'),
    ('crm:E22_Man-Made_Object1', 'crm:P41i_was_classified_by', 'crm:E17_Type_Assignment1'),
    ('crm:E12_Production1', 'crm:P14_carried_out_by', 'crm:E39_Actor1'),
    ('crm:E39_Actor1', 'crm:P131_is_identified_by', 'crm:E82_Actor_Appellation1'),
    ('crm:E22_Man-Made_Object1', 'dcterms:subject', 'skos:Concept1'),
    ('crm:E22_Man-Made_Object1', 'crm:P138i_has_representation', 'crm:E38_Image1'),
    ('crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object2'),
    ('crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object3')
]
</Step2>



Let's think step by step.

### Step 1: Establish Internal Links Between Semantic Types

1. **crm:E22_Man-Made_Object1** is the central node for the object, so we start with it.
2. **crm:E42_Identifier1** and **crm:E42_Identifier2** are identifiers for the object, so they should be linked to **crm:E22_Man-Made_Object1**.
3. **crm:E38_Image1** is an image of the object, so it should be linked to **crm:E22_Man-Made_Object1**.
4. **crm:E52_Time-Span1** represents the date of the object, so it should be linked to **crm:E12_Production1**.
5. **crm:E53_Place1** represents the geography of the object, so it should be linked to **crm:E12_Production1**.
6. **crm:E57_Material1** represents the medium of the object, so it should be linked to **crm:E12_Production1**.
7. **crm:E54_Dimension1** represents the dimensions of the object, so it should be linked to **crm:E22_Man-Made_Object1**.
8. **crm:E55_Type1** represents the classification of the object, so it should be linked to **crm:E17_Type_Assignment1**.
9. **crm:E33_Linguistic_Object1** represents the credit line of the object, so it should be linked to **crm:E22_Man-Made_Object1**.
10. **crm:E33_Linguistic_Object2** represents the description of the object, so it should be linked to **crm:E22_Man-Made_Object1**.
11. **crm:E33_Linguistic_Object3** represents the provenance of the object, so it should be linked to **crm:E22_Man-Made_Object1**.
12. **crm:E82_Actor_Appellation1** represents the artist's name, so it should be linked to **crm:E39_Actor1**.
13. **skos:Concept1** represents the keywords of the object, so it should be linked to **crm:E22_Man-Made_Object1**.

### Step 2: Review and Connect Isolated Nodes

1. **crm:E17_Type_Assignment1** is linked to **crm:E22_Man-Made_Object1** through **crm:E55_Type1**.
2. **crm:E12_Production1** is linked to **crm:E22_Man-Made_Object1** through production.
3. **crm:E39_Actor1** is linked to **crm:E22_Man-Made_Object1** through **crm:E12_Production1**.

### Step 3: Update Step 1 Solution

No updates are needed to the Step 1 solution as all nodes are connected.

### Step 4: Output the Final Internal Links

<Step2>
[
    ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier1'],
    ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier2'],
    ['crm:E22_Man-Made_Object1', 'crm:P138i_has_representation', 'crm:E38_Image1'],
    ['crm:E22_Man-Made_Object1', 'crm:P108i_was_produced_by', 'crm:E12_Production1'],
    ['crm:E12_Production1', 'crm:P4_has_time-span', 'crm:E52_Time-Span1'],
    ['crm:E12_Production1', 'crm:P7_took_place_at', 'crm:E53_Place1'],
    ['crm:E12_Production1', 'crm:P126_employed', 'crm:E57_Material1'],
    ['crm:E22_Man-Made_Object1', 'crm:P41i_was_classified_by', 'crm:E17_Type_Assignment1'],
    ['crm:E17_Type_Assignment1', 'crm:P42_assigned', 'crm:E55_Type1'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object1'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object2'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object3'],
    ['crm:E22_Man-Made_Object1', 'crm:P14_carried_out_by', 'crm:E39_Actor1'],
    ['crm:E39_Actor1', 'crm:P131_is_identified_by', 'crm:E82_Actor_Appellation1'],
    ['crm:E22_Man-Made_Object1', 'dcterms:subject', 'skos:Concept1'],
    ['crm:E22_Man-Made_Object1', 'crm:P43_has_dimension', 'crm:E54_Dimension1']
]
</Step2>


Let's think step by step.

### Step 1: Establish Internal Links Between Semantic Types

1. **Identify Core Entities and Their Relationships:**
   - `crm:E22_Man-Made_Object1` is the core entity representing the object.
   - `crm:E12_Production1` represents the production event of the object.
   - `crm:E39_Actor1` represents the artist or maker.
   - `crm:E52_Time-Span1` represents the time span of the production.
   - `crm:E53_Place1` represents the geography or location.
   - `crm:E57_Material1` represents the medium.
   - `crm:E54_Dimension1` represents the dimensions.
   - `crm:E55_Type1` represents the classification.
   - `crm:E33_Linguistic_Object1` represents the credit line.
   - `crm:E42_Identifier1` and `crm:E42_Identifier2` represent the identifiers (id and accession number).
   - `crm:E38_Image1` represents the image.
   - `skos:Concept1` represents the keywords.
   - `crm:E33_Linguistic_Object2` represents the description.
   - `crm:E33_Linguistic_Object3` represents the provenance.

2. **Establish Relationships:**
   - `crm:E22_Man-Made_Object1` is produced by `crm:E12_Production1`.
   - `crm:E12_Production1` is carried out by `crm:E39_Actor1`.
   - `crm:E12_Production1` has a time span `crm:E52_Time-Span1`.
   - `crm:E22_Man-Made_Object1` is located in `crm:E53_Place1`.
   - `crm:E22_Man-Made_Object1` is made of `crm:E57_Material1`.
   - `crm:E22_Man-Made_Object1` has dimensions `crm:E54_Dimension1`.
   - `crm:E22_Man-Made_Object1` is classified as `crm:E55_Type1`.
   - `crm:E22_Man-Made_Object1` has a credit line `crm:E33_Linguistic_Object1`.
   - `crm:E22_Man-Made_Object1` has identifiers `crm:E42_Identifier1` and `crm:E42_Identifier2`.
   - `crm:E22_Man-Made_Object1` has an image `crm:E38_Image1`.
   - `crm:E22_Man-Made_Object1` has keywords `skos:Concept1`.
   - `crm:E22_Man-Made_Object1` has a description `crm:E33_Linguistic_Object2`.
   - `crm:E22_Man-Made_Object1` has provenance `crm:E33_Linguistic_Object3`.

### Step 2: Review and Update Isolated Semantic Types

- **Isolated Semantic Types:**
  - `crm:E82_Actor_Appellation1` (Who) is isolated.
  - `crm:E17_Type_Assignment1` (type_assignment_uri) is isolated.

- **Update Step 1:**
  - `crm:E39_Actor1` is identified by `crm:E82_Actor_Appellation1`.
  - `crm:E22_Man-Made_Object1` is classified by `crm:E17_Type_Assignment1`.

### Step 3: Final Internal Links

- **Final Internal Links:**
  - `crm:E22_Man-Made_Object1` is produced by `crm:E12_Production1`.
  - `crm:E12_Production1` is carried out by `crm:E39_Actor1`.
  - `crm:E39_Actor1` is identified by `crm:E82_Actor_Appellation1`.
  - `crm:E12_Production1` has a time span `crm:E52_Time-Span1`.
  - `crm:E22_Man-Made_Object1` is located in `crm:E53_Place1`.
  - `crm:E22_Man-Made_Object1` is made of `crm:E57_Material1`.
  - `crm:E22_Man-Made_Object1` has dimensions `crm:E54_Dimension1`.
  - `crm:E22_Man-Made_Object1` is classified by `crm:E17_Type_Assignment1`.
  - `crm:E17_Type_Assignment1` assigns `crm:E55_Type1`.
  - `crm:E22_Man-Made_Object1` has a credit line `crm:E33_Linguistic_Object1`.
  - `crm:E22_Man-Made_Object1` has identifiers `crm:E42_Identifier1` and `crm:E42_Identifier2`.
  - `crm:E22_Man-Made_Object1` has an image `crm:E38_Image1`.
  - `crm:E22_Man-Made_Object1` has keywords `skos:Concept1`.
  - `crm:E22_Man-Made_Object1` has a description `crm:E33_Linguistic_Object2`.
  - `crm:E22_Man-Made_Object1` has provenance `crm:E33_Linguistic_Object3`.

### Step 4: Output Final Internal Links

<Step2>
[
    ['crm:E22_Man-Made_Object1', 'crm:P108i_was_produced_by', 'crm:E12_Production1'],
    ['crm:E12_Production1', 'crm:P14_carried_out_by', 'crm:E39_Actor1'],
    ['crm:E39_Actor1', 'crm:P131_is_identified_by', 'crm:E82_Actor_Appellation1'],
    ['crm:E12_Production1', 'crm:P4_has_time-span', 'crm:E52_Time-Span1'],
    ['crm:E22_Man-Made_Object1', 'crm:P53_has_former_or_current_location', 'crm:E53_Place1'],
    ['crm:E22_Man-Made_Object1', 'crm:P45_consists_of', 'crm:E57_Material1'],
    ['crm:E22_Man-Made_Object1', 'crm:P43_has_dimension', 'crm:E54_Dimension1'],
    ['crm:E22_Man-Made_Object1', 'crm:P41i_was_classified_by', 'crm:E17_Type_Assignment1'],
    ['crm:E17_Type_Assignment1', 'crm:P42_assigned', 'crm:E55_Type1'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object1'],
    ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier1'],
    ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier2'],
    ['crm:E22_Man-Made_Object1', 'crm:P138i_has_representation', 'crm:E38_Image1'],
    ['crm:E22_Man-Made_Object1', 'dcterms:subject', 'skos:Concept1'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object2'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object3']
]
</Step2>

import os
import json

#The system can add number to the semantic types to distinguish the different semantic type nodes with the same name. For example: crm:E42_Identifier1, crm:E42_Identifier2, crm:E42_Identifier3 represent different semantic type nodes.
def generate_prompt_chain(train_data, test_data, model, ontologies, with_inst=False):
    """Generate a prompt chain for the LLM based on the table data and ontologies."""
    system_prompt = "You are a helpful assistant that can generate semantic graphs for tables based on the ontologies given(delimited by '<Ontology>' and '</Ontology>') and the table data given(delimited by '<Table>' and '</Table>'). \
        In the Ontology part, nodes is delimited by '<Nodes>' and '</Nodes>', properties is delimited by '<Properties>' and '</Properties>', and potential triples is delimited by '<PotentialTriples>' and '</PotentialTriples>'. The symbol '->' in the ontology is used to represent the 'is parent class of' relation. \
        In the Table part, each table is a list of dictionaries, where each dictionary represents a row of the table, and the key-value pairs are the column names and their corresponding values."
    nodes = []
    properties = []
    potential_triples = []
    for ontology_name, ontology_data in ontologies.items():
        for node in ontology_data['Nodes']:
            nodes.append(node)
        for prop in ontology_data['Properties']:
            properties.append(prop)
        for triples in ontology_data['Potential triples']:
            potential_triples.append(triples.replace("<", "[").replace(">", "]"))
    system_prompt += f"<Ontology> <Nodes> {nodes}</Nodes> \n <Properties> {properties}</Properties> \n <PotentialTriples> {potential_triples}</PotentialTriples></Ontology> \n"
    system_prompt += "You will solve the task by two steps: Step1(delimited by '<Step1>' and '</Step1>') Identify the appropriate semantic type and property for each column in the table. Step2(delimited by '<Step2>' and '</Step2>') Generate a semantic graph for the table. The solution are delimited by '<Solution>' and '</Solution>'.\n\
The examples of tasks are delimited by '<Examples>' and '</Examples>'. \n"
    examples = "<Examples>"
    for example_data in train_data:
        examples += f"<Table> {example_data['table']} </Table>\n"
        examples += "<Solution>\n"
        examples += f"<Step1> {example_data['semantic_graph']['SetSemanticType']} </Step1>\n"
        examples += f"<Step2> {example_data['semantic_graph']['SetInternalLink']} </Step2>\n"
        examples += "</Solution>"
    examples += "</Examples>"
    system_prompt += examples
# 2. Extract the column names and their corresponding row values from the lists of dictionaries. \n\
# 4. Rethink the internal links and the list of triples of semantic types and properties, change the unlogical part of internal links and list of triples of semantic types and properties. \n\
    chain_prompt_1 = "Step1 SetSemanticType: \n\
The system will first identify the appropriate semantic type and property for each column in the table. \n\
Solution Steps: \n\
1. Begin the response with 'Let's think step by step'. \n\
2. Following the reasoning steps, search the potential triples in the ontology to find the appropriate semantic types for each column in the table by reasoning the column name and the row values. All columns must be mapped to the Ontology. \
3. Following with reasoning steps, identify the appropriate semantic types from nodes in the ontology for each column in the table by reasoning the column name and the row values. All columns must be mapped to the Ontology. \
ONLY if all of the row values in the column are <Empty>, the system will take the column name into consideration to find the appropriate semantic types from nodes in the ontology. \n\
4. Find the appropriate properties from properties in the ontology to link the columns and the semantic types by reasoning the column names, the row values and the semantic types. \n\
5. The system will output the semantic types and properties in the format of a list of triples, where each triple has the form (subject, predicate, object). The subject is the semantic type, the predicate is the property, and the object is the column in the table.\
Please output the list of triples using <Step1> </Step1> tags in the format of in the Step1 of examples. For example: <Step1> [(semantic_type, property, column), (semantic_type, property, column), ...] </Step1>. "
    table  =f"<Table> {test_data} </Table>"
    chain_prompt_1 = chain_prompt_1 + table
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": chain_prompt_1}
    ]
    response = model.chat.completions.create(
    model="deepseek-chat",
    # model="gpt-3.5-turbo",
    messages=messages,
        stream=False
    )
    response_content = response.choices[0].message.content
    messages.append({"role": "assistant", "content": response_content})
    set_semantic_type = response_content.split("<Step1>")[1].split("</Step1>")[0]
    print(response_content)
#3. Review internal links and the list of triples of semantic types and properties, find the same semantic type which link to different internal nodes or the same internal node linked to different internal nodes. add a number to these semantic types and internal nodes to distinguish the different the nodes in the graph with the same name. \n\
    chain_prompt_2 = " Let us do Step2 given the table and Step1. \n\
Step2 Problem Statement: \n\
Given the list of triples of semantic types and properties for the table(delimited by '<Step1>' and '</Step1>') and the original table, generate a semantic graph for the table. The semantic graph is a graph with nodes and edges. \
The nodes are the semantic types or internal nodes in the ontology, and the edges are the properties. \n\
Solution: \n\
1. Begin the response with 'Let's think step by step'. \n\
2. Following with reasoning steps, establish internal links between the semantic types based on the properties defined in the ontology and the nodes in the ontology. Eevery node must be connected to the graph.\n\
3. Review the internal links and the list of triples of semantic types and properties to find the semantic types which is isolated from the graph. Go back to Step1 to find the appropriate semantic types for these isolated semantic types to ensure all semantic types are connected in the graph and after that update the step1 solution. \n\
4. Output the final internal links using <Step2> </Step2> tag in the format of in the Step2 of examples. For example: <Step2> [(internal_node, property, internal_node), (internal_node, property, semantic_type), (internal_node, property, internal_node), ...] </Step2>.\n"
    chain_prompt_2 = chain_prompt_2 + f"<Step1> {set_semantic_type} </Step1>\n" + table
    messages2 = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": chain_prompt_2}
    ]
    response = model.chat.completions.create(
        model="deepseek-chat",
        messages=messages2,
        stream=False,
    )
    response_content = response.choices[0].message.content
    messages2.append({"role": "assistant", "content": response_content})
    return response_content, messages2





print(res)
Let's think step by step.

### Step 1: Establish Internal Links Between Semantic Types

1. **crm:E42_Identifier** is connected to **crm:E22_Man-Made_Object** via **crm:P1_is_identified_by**.
2. **crm:E38_Image** is connected to **crm:E22_Man-Made_Object** via **crm:P138i_has_representation**.
3. **crm:E52_Time-Span** is connected to **crm:E12_Production** via **crm:P4_has_time-span**.
4. **crm:E53_Place** is connected to **crm:E12_Production** via **crm:P7_took_place_at**.
5. **crm:E57_Material** is connected to **crm:E22_Man-Made_Object** via **crm:P45_consists_of**.
6. **crm:E54_Dimension** is connected to **crm:E22_Man-Made_Object** via **crm:P43_has_dimension**.
7. **crm:E55_Type** is connected to **crm:E17_Type_Assignment** via **crm:P42_assigned**.
8. **crm:E33_Linguistic_Object** (Credit Line, Description, Provenance) is connected to **crm:E22_Man-Made_Object** via **crm:P67i_is_referred_to_by**.
9. **crm:E42_Identifier** (Accession Number) is connected to **crm:E22_Man-Made_Object** via **crm:P1_is_identified_by**.
10. **crm:E17_Type_Assignment** is connected to **crm:E22_Man-Made_Object** via **crm:P41i_was_classified_by**.
11. **crm:E12_Production** is connected to **crm:E22_Man-Made_Object** via **crm:P108i_was_produced_by**.
12. **crm:E82_Actor_Appellation** is connected to **crm:E39_Actor** via **crm:P131_is_identified_by**.
13. **crm:E39_Actor** is connected to **crm:E12_Production** via **crm:P14_carried_out_by**.
14. **skos:Concept** is connected to **crm:E22_Man-Made_Object** via **dcterms:subject**.

### Step 2: Review and Update Isolated Semantic Types

- **crm:E52_Time-Span** is connected to **crm:E12_Production** via **crm:P4_has_time-span**.
- **crm:E53_Place** is connected to **crm:E12_Production** via **crm:P7_took_place_at**.
- **crm:E57_Material** is connected to **crm:E22_Man-Made_Object** via **crm:P45_consists_of**.
- **crm:E54_Dimension** is connected to **crm:E22_Man-Made_Object** via **crm:P43_has_dimension**.
- **crm:E55_Type** is connected to **crm:E17_Type_Assignment** via **crm:P42_assigned**.
- **crm:E33_Linguistic_Object** (Credit Line, Description, Provenance) is connected to **crm:E22_Man-Made_Object** via **crm:P67i_is_referred_to_by**.
- **crm:E42_Identifier** (Accession Number) is connected to **crm:E22_Man-Made_Object** via **crm:P1_is_identified_by**.
- **crm:E17_Type_Assignment** is connected to **crm:E22_Man-Made_Object** via **crm:P41i_was_classified_by**.
- **crm:E12_Production** is connected to **crm:E22_Man-Made_Object** via **crm:P108i_was_produced_by**.
- **crm:E82_Actor_Appellation** is connected to **crm:E39_Actor** via **crm:P131_is_identified_by**.
- **crm:E39_Actor** is connected to **crm:E12_Production** via **crm:P14_carried_out_by**.
- **skos:Concept** is connected to **crm:E22_Man-Made_Object** via **dcterms:subject**.

### Step 3: Final Internal Links

<Step2>
[
    ['crm:E22_Man-Made_Object', 'crm:P1_is_identified_by', 'crm:E42_Identifier'],
    ['crm:E22_Man-Made_Object', 'crm:P138i_has_representation', 'crm:E38_Image'],
    ['crm:E22_Man-Made_Object', 'crm:P108i_was_produced_by', 'crm:E12_Production'],
    ['crm:E12_Production', 'crm:P4_has_time-span', 'crm:E52_Time-Span'],
    ['crm:E12_Production', 'crm:P7_took_place_at', 'crm:E53_Place'],
    ['crm:E22_Man-Made_Object', 'crm:P45_consists_of', 'crm:E57_Material'],
    ['crm:E22_Man-Made_Object', 'crm:P43_has_dimension', 'crm:E54_Dimension'],
    ['crm:E22_Man-Made_Object', 'crm:P41i_was_classified_by', 'crm:E17_Type_Assignment'],
    ['crm:E17_Type_Assignment', 'crm:P42_assigned', 'crm:E55_Type'],
    ['crm:E22_Man-Made_Object', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object'],
    ['crm:E22_Man-Made_Object', 'crm:P1_is_identified_by', 'crm:E42_Identifier'],
    ['crm:E12_Production', 'crm:P14_carried_out_by', 'crm:E39_Actor'],
    ['crm:E39_Actor', 'crm:P131_is_identified_by', 'crm:E82_Actor_Appellation'],
    ['crm:E22_Man-Made_Object', 'dcterms:subject', 'skos:Concept']
]
</Step2>


Let's think step by step.

### Step 1: Establish Internal Links Between Semantic Types

1. **Identify Core Entities and Their Relationships:**
   - The core entity in this context is `crm:E22_Man-Made_Object1` (the object).
   - The object is produced (`crm:E12_Production1`), classified (`crm:E17_Type_Assignment1`), and has various attributes like dimensions (`crm:E54_Dimension1`), medium (`crm:E57_Material1`), and place (`crm:E53_Place1`).
   - The object is also identified by various identifiers (`crm:E42_Identifier1`, `crm:E42_Identifier2`).

2. **Link Production to Object:**
   - `crm:E22_Man-Made_Object1` is produced by `crm:E12_Production1`.
   - `crm:E12_Production1` has a time span (`crm:E52_Time-Span1`).

3. **Link Object to Classification:**
   - `crm:E22_Man-Made_Object1` is classified by `crm:E17_Type_Assignment1`.
   - `crm:E17_Type_Assignment1` assigns a type (`crm:E55_Type1`).

4. **Link Object to Attributes:**
   - `crm:E22_Man-Made_Object1` has dimensions (`crm:E54_Dimension1`), medium (`crm:E57_Material1`), and place (`crm:E53_Place1`).

5. **Link Object to Identifiers:**
   - `crm:E22_Man-Made_Object1` is identified by `crm:E42_Identifier1` and `crm:E42_Identifier2`.

6. **Link Object to Descriptive Information:**
   - `crm:E22_Man-Made_Object1` has a credit line (`crm:E33_Linguistic_Object1`), description (`crm:E33_Linguistic_Object2`), and provenance (`crm:E33_Linguistic_Object3`).

7. **Link Object to Artist:**
   - `crm:E12_Production1` is carried out by an artist (`crm:E39_Actor1`).
   - The artist is identified by an appellation (`crm:E82_Actor_Appellation1`).

8. **Link Object to Keywords:**
   - `crm:E22_Man-Made_Object1` has keywords (`skos:Concept1`).

9. **Link Object to Image:**
   - `crm:E22_Man-Made_Object1` has an image (`crm:E38_Image1`).

### Step 2: Review and Ensure All Semantic Types Are Connected

- **Isolated Nodes:** None of the nodes are isolated as they are all connected through the core entity `crm:E22_Man-Made_Object1`.

### Step 3: Update Step 1 Solution (if necessary)

- No updates are necessary as all nodes are already connected.

### Step 4: Output the Final Internal Links

<Step2>
[
    ['crm:E22_Man-Made_Object1', 'crm:P108i_was_produced_by', 'crm:E12_Production1'],
    ['crm:E12_Production1', 'crm:P4_has_time-span', 'crm:E52_Time-Span1'],
    ['crm:E22_Man-Made_Object1', 'crm:P41i_was_classified_by', 'crm:E17_Type_Assignment1'],
    ['crm:E17_Type_Assignment1', 'crm:P42_assigned', 'crm:E55_Type1'],
    ['crm:E22_Man-Made_Object1', 'crm:P43_has_dimension', 'crm:E54_Dimension1'],
    ['crm:E22_Man-Made_Object1', 'crm:P45_consists_of', 'crm:E57_Material1'],
    ['crm:E22_Man-Made_Object1', 'crm:P7_took_place_at', 'crm:E53_Place1'],
    ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier1'],
    ['crm:E22_Man-Made_Object1', 'crm:P1_is_identified_by', 'crm:E42_Identifier2'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object1'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object2'],
    ['crm:E22_Man-Made_Object1', 'crm:P67i_is_referred_to_by', 'crm:E33_Linguistic_Object3'],
    ['crm:E22_Man-Made_Object1', 'crm:P138i_has_representation', 'crm:E38_Image1'],
    ['crm:E12_Production1', 'crm:P14_carried_out_by', 'crm:E39_Actor1'],
    ['crm:E39_Actor1', 'crm:P131_is_identified_by', 'crm:E82_Actor_Appellation1'],
    ['crm:E22_Man-Made_Object1', 'dcterms:subject', 'skos:Concept1']
]
</Step2>


import os
import json

#The system can add number to the semantic types to distinguish the different semantic type nodes with the same name. For example: crm:E42_Identifier1, crm:E42_Identifier2, crm:E42_Identifier3 represent different semantic type nodes.
def generate_prompt_chain(train_data, test_data, model, ontologies, with_inst=False):
    """Generate a prompt chain for the LLM based on the table data and ontologies."""
    system_prompt = "You are a helpful assistant that can generate semantic graphs for tables based on the ontologies given(delimited by '<Ontology>' and '</Ontology>') and the table data given(delimited by '<Table>' and '</Table>'). \
        In the Ontology part, nodes is delimited by '<Nodes>' and '</Nodes>', properties is delimited by '<Properties>' and '</Properties>', and potential triples is delimited by '<PotentialTriples>' and '</PotentialTriples>'. The symbol '->' in the ontology is used to represent the 'is parent class of' relation. \
        In the Table part, each table is a list of dictionaries, where each dictionary represents a row of the table, and the key-value pairs are the column names and their corresponding values."
    nodes = []
    properties = []
    potential_triples = []
    for ontology_name, ontology_data in ontologies.items():
        for node in ontology_data['Nodes']:
            nodes.append(node)
        for prop in ontology_data['Properties']:
            properties.append(prop)
        for triples in ontology_data['Potential triples']:
            potential_triples.append(triples.replace("<", "[").replace(">", "]"))
    system_prompt += f"<Ontology> <Nodes> {nodes}</Nodes> \n <Properties> {properties}</Properties> \n <PotentialTriples> {potential_triples}</PotentialTriples></Ontology> \n"
    system_prompt += "You will solve the task by two steps: Step1(delimited by '<Step1>' and '</Step1>') Identify the appropriate semantic type and property for each column in the table. Step2(delimited by '<Step2>' and '</Step2>') Generate a semantic graph for the table. The solution are delimited by '<Solution>' and '</Solution>'.\n\
The examples of tasks are delimited by '<Examples>' and '</Examples>'. \n"
    examples = "<Examples>"
    for example_data in train_data:
        examples += f"<Table> {example_data['table']} </Table>\n"
        examples += "<Solution>\n"
        examples += f"<Step1> {example_data['semantic_graph']['SetSemanticType']} </Step1>\n"
        examples += f"<Step2> {example_data['semantic_graph']['SetInternalLink']} </Step2>\n"
        examples += "</Solution>"
    examples += "</Examples>"
    system_prompt += examples
# 2. Extract the column names and their corresponding row values from the lists of dictionaries. \n\
# 4. Rethink the internal links and the list of triples of semantic types and properties, change the unlogical part of internal links and list of triples of semantic types and properties. \n\
    chain_prompt_1 = "Step1 SetSemanticType: \n\
The system will first identify the appropriate semantic type and property for each column in the table. \n\
Solution Steps: \n\
1. Begin the response with 'Let's think step by step'. \n\
2. Following the reasoning steps, search the potential triples in the ontology to find the appropriate semantic types for each column in the table by reasoning the column name and the row values. All columns must be mapped to the Ontology. \
3. Following with reasoning steps, identify the appropriate semantic types from nodes in the ontology for each column in the table by reasoning the column name and the row values. All columns must be mapped to the Ontology. \
ONLY if all of the row values in the column are <Empty>, the system will take the column name into consideration to find the appropriate semantic types from nodes in the ontology. \n\
4. Find the appropriate properties from properties in the ontology to link the columns and the semantic types by reasoning the column names, the row values and the semantic types. \n\
5. The system will output the semantic types and properties in the format of a list of triples, where each triple has the form (subject, predicate, object). The subject is the semantic type, the predicate is the property, and the object is the column in the table.\
Please output the list of triples using <Step1> </Step1> tags in the format of in the Step1 of examples. For example: <Step1> [(semantic_type, property, column), (semantic_type, property, column), ...] </Step1>. "
    table  =f"<Table> {test_data} </Table>"
    chain_prompt_1 = chain_prompt_1 + table
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": chain_prompt_1}
    ]
    response = model.chat.completions.create(
    model="deepseek-chat",
    # model="gpt-3.5-turbo",
    messages=messages,
        stream=False
    )
    response_content = response.choices[0].message.content
    messages.append({"role": "assistant", "content": response_content})
    set_semantic_type = response_content.split("<Step1>")[1].split("</Step1>")[0]
    print(response_content)
#3. Review internal links and the list of triples of semantic types and properties, find the same semantic type which link to different internal nodes or the same internal node linked to different internal nodes. add a number to these semantic types and internal nodes to distinguish the different the nodes in the graph with the same name. \n\
    chain_prompt_2 = " Let us do Step2 given the table and Step1. \n\
Step2 Problem Statement: \n\
Given the list of triples of semantic types and properties for the table(delimited by '<Step1>' and '</Step1>') and the original table, generate a semantic graph for the table. The semantic graph is a graph with nodes and edges. \
The nodes are the semantic types or internal nodes in the ontology, and the edges are the properties. \n\
Solution: \n\
1. Begin the response with 'Let's think step by step'. \n\
2. Following with reasoning steps, establish internal links between the semantic types based on the properties defined in the ontology and the nodes in the ontology. Eevery node must be connected to the graph.\n\
3. Review the internal links and the list of triples of semantic types and properties to find the semantic types which is isolated from the graph. Go back to Step1 to find the appropriate semantic types for these isolated semantic types to ensure all semantic types are connected in the graph and after that update the step1 solution. Hint: The graph is a tree structure.\n\
4. Output the final internal links using <Step2> </Step2> tag in the format of in the Step2 of examples. For example: <Step2> [(internal_node, property, internal_node), (internal_node, property, semantic_type), (internal_node, property, internal_node), ...] </Step2>.\n"
    chain_prompt_2 = chain_prompt_2 + f"<Step1> {set_semantic_type} </Step1>\n" + table
    messages2 = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": chain_prompt_2}
    ]
    response = model.chat.completions.create(
        model="deepseek-chat",
        messages=messages2,
        stream=False,
    )
    response_content = response.choices[0].message.content
    messages2.append({"role": "assistant", "content": response_content})
    return response_content, messages2


You are tasked with generating semantic graphs based on the provided ontology and table data. Follow
these steps to accomplish this task:

1. **Understand the Ontology Structure:**
- The ontology is defined within the <Ontology> tags.
- Nodes are listed within <Nodes> tags, properties within <Properties> tags, and potential triples
within <PotentialTriples> tags.
- The symbol '->' represents the 'is parent class of' relation.

<Ontology>
{$ONTOLOGY}
</Ontology>

2. **Examine the Table Data:**
- Each table is a list of dictionaries, where each dictionary represents a row of the table.
- The key-value pairs in each dictionary are the column names and their corresponding values.

<Table>
{$TABLE}
</Table>

3. **Review the Examples:**
- Examples are provided to illustrate how to map the table data to the ontology and generate the
semantic graph.

<Examples>
{$EXAMPLES}
</Examples>

4. **Generate the Semantic Graph:**
- For each row in the table, identify the relevant nodes and properties from the ontology.
- Create triples based on the potential triples defined in the ontology and the values from the
table.
- Ensure that the triples respect the 'is parent class of' relations defined in the ontology.

5. **Output the Semantic Graph:**
- Write the generated semantic graph inside <SemanticGraph> tags.
- Each triple should be formatted as "Subject - Predicate - Object".

<SemanticGraph>
<!-- Write your generated semantic graph here -->
</SemanticGraph>

<SemanticGraph>
{
"SetSemanticType": [
["crm:E82_Actor_Appellation1", "rdf:value", "Frishmuth, Harriet Whitney"],
["crm:E52_Time-Span1", "karma:classLink", "www.imamuseum.org/person/Frishmuth, Harriet
Whitney/birth_date"],
["crm:E52_Time-Span1", "crm:P82a_begin_of_the_begin", "1880-01-01"],
["crm:E52_Time-Span1", "crm:P82b_end_of_the_end", "1880-12-31"],
["crm:E52_Time-Span1", "rdfs:label", "1880"],
["crm:E52_Time-Span2", "karma:classLink", "www.imamuseum.org/person/Frishmuth, Harriet
Whitney/death_date"],
["crm:E52_Time-Span2", "crm:P82a_begin_of_the_begin", "1980-01-01"],
["crm:E52_Time-Span2", "crm:P82b_end_of_the_end", "1980-12-31"],
["crm:E52_Time-Span2", "rdfs:label", "1980"],
["crm:E74_Group1", "rdfs:label", "American"],
["crm:E39_Actor1", "karma:classLink", "www.imamuseum.org/person/Frishmuth, Harriet Whitney"],
["crm:E63_Beginning_of_Existence1", "karma:classLink", "www.imamuseum.org/person/Frishmuth, Harriet
Whitney/birth"],
["crm:E64_End_of_Existence1", "karma:classLink", "www.imamuseum.org/person/Frishmuth, Harriet
Whitney/death"]
],
"SetInternalLink": [
["crm:E39_Actor1", "crm:P131_is_identified_by", "crm:E82_Actor_Appellation1"],
["crm:E39_Actor1", "crm:P92i_was_brought_into_existence_by", "crm:E63_Beginning_of_Existence1"],
["crm:E39_Actor1", "crm:P93i_was_taken_out_of_existence_by", "crm:E64_End_of_Existence1"],
["crm:E63_Beginning_of_Existence1", "crm:P4_has_time-span", "crm:E52_Time-Span1"],
["crm:E64_End_of_Existence1", "crm:P4_has_time-span", "crm:E52_Time-Span2"],
["crm:E39_Actor1", "crm:P107i_is_current_or_former_member_of", "crm:E74_Group1"]
]
}
</SemanticGraph>



#### **Example 1: Artworks Table**

**Attributes and Mappings:**
- `Attribution` -> `crm:E82_Actor_Appellation1`, `rdf:value`
- `ArtistURI` -> `crm:E39_Actor1`, `karma:classLink`
- `ArtistAppellationURI` -> `crm:E82_Actor_Appellation1`, `karma:classLink`
- `Begin Date` -> `crm:E52_Time-Span1`, `rdfs:label`
- `BirthDateLatest` -> `crm:E52_Time-Span1`, `crm:P82b_end_of_the_end`
- `BirthDateEarliest` -> `crm:E52_Time-Span1`, `crm:P82a_begin_of_the_begin`
- `BirthDateURI` -> `crm:E52_Time-Span1`, `karma:classLink`
- `BirthURI` -> `crm:E63_Beginning_of_Existence1`, `karma:classLink`
- `End Date` -> `crm:E52_Time-Span2`, `rdfs:label`
- `DeathDateLatest` -> `crm:E52_Time-Span2`, `crm:P82b_end_of_the_end`
- `DeathDateEarliest` -> `crm:E52_Time-Span2`, `crm:P82a_begin_of_the_begin`
- `DeathDateURI` -> `crm:E52_Time-Span2`, `karma:classLink`
- `DeathURI` -> `crm:E64_End_of_Existence1`, `karma:classLink`
- `ObjectURI` -> `crm:E22_Man-Made_Object1`, `karma:classLink`
- `ProductionURI` -> `crm:E12_Production1`, `karma:classLink`
- `Dated` -> `crm:E52_Time-Span3`, `rdfs:label`
- `ProductionDateURI` -> `crm:E52_Time-Span3`, `karma:classLink`
- `DateEnd` -> `crm:E52_Time-Span3`, `crm:P82b_end_of_the_end`
- `DateBegin` -> `crm:E52_Time-Span3`, `crm:P82a_begin_of_the_begin`
- `Medium` -> `crm:E33_Linguistic_Object1`, `rdf:value`
- `MediumURI` -> `crm:E33_Linguistic_Object1`, `karma:classLink`
- `Dimensions` -> `crm:E33_Linguistic_Object2`, `rdf:value`
- `DimensionURI` -> `crm:E33_Linguistic_Object2`, `karma:classLink`

#### **Example 2: Dallas Museum of Art Table**

**Attributes and Mappings:**
- `Object ID` -> `crm:E42_Identifier1`, `rdf:value`
- `ObjectURI` -> `crm:E22_Man-Made_Object1`, `karma:classLink`
- `object_id_uri` -> `crm:E42_Identifier2`, `karma:classLink`
- `accession_uri` -> `crm:E42_Identifier1`, `karma:classLink`
- `TypeAssignmentURI` -> `crm:E17_Type_Assignment1`, `karma:classLink`
- `ProductionURI` -> `crm:E12_Production1`, `karma:classLink`
- `ProductionDateURI` -> `crm:E52_Time-Span3`, `karma:classLink`
- `Object Title` -> `crm:E35_Title1`, `rdf:value`
- `Object Work Type` -> `crm:E55_Type1`, `rdfs:label`
- `Alternate Object ID` -> `crm:E42_Identifier2`, `rdf:value`
- `Artist Name` -> `crm:E82_Actor_Appellation1`, `rdf:value`
- `NameURI` -> `crm:E82_Actor_Appellation1`, `karma:classLink`
- `ArtistURI` -> `crm:E39_Actor1`, `karma:classLink`
- `DeathDateURI` -> `crm:E52_Time-Span2`, `karma:classLink`
- `DeathURI` -> `crm:E64_End_of_Existence1`, `karma:classLink`
- `BirthDateURI` -> `crm:E52_Time-Span1`, `karma:classLink`
- `BirthURI` -> `crm:E63_Beginning_of_Existence1`, `karma:classLink`
- `Artist Birth Date` -> `crm:E52_Time-Span1`, `rdfs:label`
- `BirthDateLatest` -> `crm:E52_Time-Span1`, `crm:P82b_end_of_the_end`
- `BirthDateEarliest` -> `crm:E52_Time-Span1`, `crm:P82a_begin_of_the_begin`
- `Artist Death Date` -> `crm:E52_Time-Span2`, `rdfs:label`
- `DeathDateLatest` -> `crm:E52_Time-Span2`, `crm:P82b_end_of_the_end`
- `DeathDateEarliest` -> `crm:E52_Time-Span2`, `crm:P82a_begin_of_the_begin`
- `Artist Nationality` -> `crm:E74_Group1`, `rdfs:label`
- `NationalityURI` -> `crm:E74_Group1`, `karma:classLink`
- `Object Earliest Date` -> `crm:E52_Time-Span3`, `crm:P82a_begin_of_the_begin`
- `Object Latest Date` -> `crm:E52_Time-Span3`, `crm:P82b_end_of_the_end`
- `Object Earliest Date Display` -> `crm:E52_Time-Span3`, `rdfs:label`
- `Object Rights` -> `crm:E33_Linguistic_Object1`, `rdf:value`
- `Object Facet Value 1` -> `crm:E33_Linguistic_Object3`, `rdf:value`
- `Object Link Source` -> `crm:E40_Legal_Body1`, `rdfs:label`
- `dimensions` -> `crm:E33_Linguistic_Object2`, `rdf:value`

#### **Example 3: Artists Table**

**Attributes and Mappings:**
- `name` -> `crm:E82_Actor_Appellation1`, `rdf:value`
- `artist_uri` -> `crm:E39_Actor1`, `karma:classLink`
- `death_uri` -> `crm:E64_End_of_Existence1`, `karma:classLink`
- `birth_uri` -> `crm:E63_Beginning_of_Existence1`, `karma:classLink`
- `nationality` -> `crm:E74_Group1`, `rdfs:label`
- `deathDate` -> `crm:E52_Time-Span2`, `rdfs:label`
- `death_date_latest` -> `crm:E52_Time-Span2`, `crm:P82b_end_of_the_end`
- `death_date_earliest` -> `crm:E52_Time-Span2`, `crm:P82a_begin_of_the_begin`
- `birthDate` -> `crm:E52_Time-Span1`, `rdfs:label`
- `birth_date_latest` -> `crm:E52_Time-Span1`, `crm:P82b_end_of_the_end`
- `birth_date_earliest` -> `crm:E52_Time-Span1`, `crm:P82a_begin_of_the_begin`

#### **Example 4: Artworks with Missing Values Table**

**Attributes and Mappings:**
- `@title` -> `crm:E35_Title1`, `rdf:value`
- `sourceURL` -> `foaf:Document1`, `karma:classLink`
- `imageURL` -> `crm:E38_Image1`, `karma:classLink`
- `artist` -> `crm:E82_Actor_Appellation1`, `rdf:value`
- `artist_uri` -> `crm:E39_Actor1`, `karma:classLink`
- `birth_uri` -> `crm:E63_Beginning_of_Existence1`, `karma:classLink`
- `nationality` -> `crm:E74_Group1`, `rdfs:label`
- `deathDate` -> `crm:E52_Time-Span2`, `rdfs:label`
- `death_uri` -> `crm:E64_End_of_Existence1`, `karma:classLink`
- `death_date_latest` -> `crm:E52_Time-Span2`, `crm:P82b_end_of_the_end`
- `death_date_earliest` -> `crm:E52_Time-Span2`, `crm:P82a_begin_of_the_begin`
- `birthDate` -> `crm:E52_Time-Span1`, `rdfs:label`
- `birth_date_latest` -> `crm:E52_Time-Span1`, `crm:P82b_end_of_the_end`
- `birth_date_earliest` -> `crm:E52_Time-Span1`, `crm:P82a_begin_of_the_begin`
- `materials` -> `crm:E33_Linguistic_Object1`, `rdf:value`
- `dimensions` -> `crm:E33_Linguistic_Object2`, `rdf:value`
- `creditLine` -> `crm:E33_Linguistic_Object3`, `rdf:value`
- `accessionNumber` -> `crm:E42_Identifier1`, `rdf:value`
- `object_uri` -> `crm:E22_Man-Made_Object1`, `karma:classLink`
- `production_uri` -> `crm:E12_Production1`, `karma:classLink`
- `creationDate` -> `crm:E52_Time-Span3`, `rdfs:label`
- `creation_date_latest` -> `crm:E52_Time-Span3`, `crm:P82b_end_of_the_end`
- `creation_date_earliest` -> `crm:E52_Time-Span3`, `crm:P82a_begin_of_the_begin`
- `galleryLabel` -> `crm:E33_Linguistic_Object4`, `rdf:value`
- `provenance` -> `crm:E33_Linguistic_Object5`, `rdf:value`
- `keywords|keyword` -> `skos:Concept1`, `skos:prefLabel`